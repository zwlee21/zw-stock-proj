

程序设计说明 ：

 1. 由于股票的实时性要求很高，并且要求服务器要有极高的稳定性，不能中断数据，
    不能有错误数据和延时数据， 只能是实时数据。

    *所以后台采用了rabbitmq queue 的消息服务器，连接java 与nodejs 服务器
     间的通信，用信息服务吞吐量会比较大，实时性高（需要设置queue不缓存数据），
     可以多点对多点连接，多点对单点连接，灵活性比较高。
     并且nodejs服务，java服务，rabbitmq-server是独立运行的，之间无依赖，
     可增加可靠性，有利于程序的故障恢复处理。
     也可以做负载均衡。
    *如果采用socket java与nodejs直连通信，吞吐量不高，不能做多点对单点传输等，
     并且java与nodejs程序不能单独运行，容易造成故障。
    *如果采用 request , response通信方式，实时性，稳定性还可以。没做深入对比。

2.  这次我假设这5个股票信息来自与5个不同的交易场所，并且是每个场所中随机的一个股票信息。
    于是用了rabbitmq 的一个exchange,10个queue,5对5连接，对于这5个交易场所有了耦合，
    需要增加交易场所时代码要更改。 但好处是实时性较高。


3.  如果时间充裕，我会做能够适应随意多个交易场所，每个场所任意多个股票信息接收显示的扩展
    设计，并且深入研究负载均衡与故障恢复机制，吞吐量测试，实时性测试等。

4.  对于下一轮数据没来的处理，用户连接看上一轮数据的处理
    我主要是缓存了上一轮数据，每次数据来时都更新这个缓存，
    当用户刚连接时首先发送缓存中的数据给用户。之后下一轮数据来时发实时数据。
  
   
     
